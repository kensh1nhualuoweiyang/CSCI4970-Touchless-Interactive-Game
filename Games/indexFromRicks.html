<!DOCTYPE html>
<html>

<head>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¯</text></svg>">
  <style>
    * {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>

  <div>
    <canvas id="canvas"></canvas>
  </div>



  <script>

    let video = document.createElement("video");
    video.autoplay = true;
    //var video = document.querySelector("#videoElement");

    if (navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(function (stream) {
          video.srcObject = stream;
        })
        .catch(function (error) {
          console.log("Something went wrong! " + error);
        });
    }



    //setInterval(loop, 10);
    let canvas = document.querySelector("#canvas")
    let ctx = canvas.getContext("2d");
    window.requestAnimationFrame(loop, canvas);
    let track = null;
    let settings = null;

    let tempCanvas = document.createElement("canvas");
    let tempCtx = tempCanvas.getContext("2d");

    let secondCanvas = document.createElement("canvas");
    let secondCtx = secondCanvas.getContext("2d");


    function loop() {
      if (video.srcObject || track) {
        track = video.srcObject.getTracks()[0];
        settings = track.getSettings();

        //document.body.appendChild(tempCanvas);

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let videoWidth = settings.width;
        let videoHeight = settings.height;
        
        tempCanvas.width = videoWidth;
        tempCanvas.height = videoHeight;
        secondCanvas.width = videoWidth;
        secondCanvas.height = videoHeight;

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let scaleX = 1;
        let scaleY = 1;
        let proposedScaleX = window.innerWidth / settings.width;
        let proposedScaleY = window.innerHeight / settings.height;
        let scale = Math.min(proposedScaleX, proposedScaleY);
        


        let offsetX = 0;
        let offsetY = 0;



        if (scale != proposedScaleX) {
          offsetX = (proposedScaleX - scale) * videoWidth / 2
        }
        else {
          offsetY = (proposedScaleY - scale) * videoHeight / 2
        }

        tempCtx.drawImage(video, 0, 0, settings.width, settings.height);

        let pixels = tempCtx.getImageData(0, 0, settings.width, settings.height);


        for (let y = 0; y < videoHeight; y++) {
          for (let x = 0; x < videoWidth; x++) {
            //The data is linear, get the x,y coordinate
            //We mulitply by 4 since it is stored as rgba
            let pixelIndex = videoWidth * 4 * y + x * 4;

            //Convert to grayscale on half the image
            if (true) {
              let r = pixels.data[pixelIndex];
              let g = pixels.data[pixelIndex + 1];
              let b = pixels.data[pixelIndex + 2];

              //Trivial grayscale conversion using the red channel
              g = r;
              b = r;

              //Update the pixel data
              pixels.data[pixelIndex] = r;
              pixels.data[pixelIndex + 1] = g;
              pixels.data[pixelIndex + 2] = b;
            }
          }
        }


        secondCtx.putImageData(pixels,0,0);
        console.log(scale);

        console.log(offsetY);
        ctx.drawImage(secondCanvas, 0, 0, videoWidth, videoHeight,
          offsetX, offsetY, scale * videoWidth, scale * videoHeight);

        //ctx.putImageData(pixels, offsetX, offsetY);




        window.requestAnimationFrame(loop, canvas);



      }
      else {
        ctx.fillStyle = "magenta"
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        window.requestAnimationFrame(loop, canvas);

      }
    }



  </script>

</body>

</html>
